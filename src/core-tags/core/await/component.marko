import EventEmitter from "events-light";

class {
  onCreate(input, out) {
    this.count = 0;
    if (typeof window !== "undefined" && window.$AR && window.$AR[this.id]) {
      this.state = window.$AR[this.id];
      this.hydrate = true;
      delete window.$AR[this.id];
    } else {
      this.state = {};
    }
  }
  onInput(input, out) {
    if (this.hydrate) {
      this.hydrate = false;
      return;
    }

    var name = input.name || input._name;
    var provider = input._provider;
    var awaitInfo = { name, provider };

    if (provider === this.provider) {
      return;
    } else {
      this.provider = provider;
    }

    events.emit("await:begin", awaitInfo);

    const count = ++this.count;
    clearTimeout(this.delay);
    if (input.delay) {
      this.delay = setTimeout(() => {
        this.state = { 
          loading:true
        };
      }, input.delay);
    } else {
      this.state = { 
        loading:true
      }
    }
    ensurePromise(provider, input.timeout || 10000).then(
      data => {
        if (this.count === count) {
          clearTimeout(this.delay);
          this.state = {
            resolved:true,
            data
          };
          events.emit("await:beforeRender", awaitInfo);
          this.once("update", () => {
            events.emit("await:finish", awaitInfo);
          });
        }
      }, 
      error => {
        if (this.count === count) {
          awaitInfo.error = error;
          clearTimeout(this.delay);
          this.state = {
            rejected:true,
            error
          };
          events.emit("await:beforeRender", awaitInfo);
          this.once("update", () => {
            events.emit("await:finish", awaitInfo);
          });
        }
      }
    );
  }
}

static var events = module.exports.events = new EventEmitter();
static class TimeoutError extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};

static function ensurePromise(provider, timeout) {
  if (!provider || !provider.then) {
    if (typeof provider === "function") {
      return Promise.reject(new TypeError("Passing a callback function to the browser implementation of the <await> tag is not supported, please use a promise instead."));
    } else {
      return Promise.resolve(provider);
    }
  }
  var timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new TimeoutError(`Timed out after ${timeout}ms`)), timeout));
  return Promise.race([provider, timeoutPromise]);
}

<if(state.loading)>
  <${input.placeholder}/>
</if>
<else-if(state.rejected)>
  <${input.catch}(state.error)/>
</else-if>
<else-if(state.resolved)>
  <${input.then}(state.data)/>
</else-if>
